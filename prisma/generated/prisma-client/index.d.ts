// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  balanceUpdate: (where?: BalanceUpdateWhereInput) => Promise<boolean>;
  broker: (where?: BrokerWhereInput) => Promise<boolean>;
  investment: (where?: InvestmentWhereInput) => Promise<boolean>;
  sequelizeMeta: (where?: SequelizeMetaWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  balanceUpdate: (
    where: BalanceUpdateWhereUniqueInput
  ) => BalanceUpdateNullablePromise;
  balanceUpdates: (args?: {
    where?: BalanceUpdateWhereInput;
    orderBy?: BalanceUpdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BalanceUpdate>;
  balanceUpdatesConnection: (args?: {
    where?: BalanceUpdateWhereInput;
    orderBy?: BalanceUpdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BalanceUpdateConnectionPromise;
  broker: (where: BrokerWhereUniqueInput) => BrokerNullablePromise;
  brokers: (args?: {
    where?: BrokerWhereInput;
    orderBy?: BrokerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Broker>;
  brokersConnection: (args?: {
    where?: BrokerWhereInput;
    orderBy?: BrokerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BrokerConnectionPromise;
  investment: (where: InvestmentWhereUniqueInput) => InvestmentNullablePromise;
  investments: (args?: {
    where?: InvestmentWhereInput;
    orderBy?: InvestmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Investment>;
  investmentsConnection: (args?: {
    where?: InvestmentWhereInput;
    orderBy?: InvestmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InvestmentConnectionPromise;
  sequelizeMeta: (
    where: SequelizeMetaWhereUniqueInput
  ) => SequelizeMetaNullablePromise;
  sequelizeMetas: (args?: {
    where?: SequelizeMetaWhereInput;
    orderBy?: SequelizeMetaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SequelizeMeta>;
  sequelizeMetasConnection: (args?: {
    where?: SequelizeMetaWhereInput;
    orderBy?: SequelizeMetaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SequelizeMetaConnectionPromise;
  transaction: (
    where: TransactionWhereUniqueInput
  ) => TransactionNullablePromise;
  transactions: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Transaction>;
  transactionsConnection: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TransactionConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBalanceUpdate: (data: BalanceUpdateCreateInput) => BalanceUpdatePromise;
  updateBalanceUpdate: (args: {
    data: BalanceUpdateUpdateInput;
    where: BalanceUpdateWhereUniqueInput;
  }) => BalanceUpdatePromise;
  updateManyBalanceUpdates: (args: {
    data: BalanceUpdateUpdateManyMutationInput;
    where?: BalanceUpdateWhereInput;
  }) => BatchPayloadPromise;
  upsertBalanceUpdate: (args: {
    where: BalanceUpdateWhereUniqueInput;
    create: BalanceUpdateCreateInput;
    update: BalanceUpdateUpdateInput;
  }) => BalanceUpdatePromise;
  deleteBalanceUpdate: (
    where: BalanceUpdateWhereUniqueInput
  ) => BalanceUpdatePromise;
  deleteManyBalanceUpdates: (
    where?: BalanceUpdateWhereInput
  ) => BatchPayloadPromise;
  createBroker: (data: BrokerCreateInput) => BrokerPromise;
  updateBroker: (args: {
    data: BrokerUpdateInput;
    where: BrokerWhereUniqueInput;
  }) => BrokerPromise;
  updateManyBrokers: (args: {
    data: BrokerUpdateManyMutationInput;
    where?: BrokerWhereInput;
  }) => BatchPayloadPromise;
  upsertBroker: (args: {
    where: BrokerWhereUniqueInput;
    create: BrokerCreateInput;
    update: BrokerUpdateInput;
  }) => BrokerPromise;
  deleteBroker: (where: BrokerWhereUniqueInput) => BrokerPromise;
  deleteManyBrokers: (where?: BrokerWhereInput) => BatchPayloadPromise;
  createInvestment: (data: InvestmentCreateInput) => InvestmentPromise;
  updateInvestment: (args: {
    data: InvestmentUpdateInput;
    where: InvestmentWhereUniqueInput;
  }) => InvestmentPromise;
  updateManyInvestments: (args: {
    data: InvestmentUpdateManyMutationInput;
    where?: InvestmentWhereInput;
  }) => BatchPayloadPromise;
  upsertInvestment: (args: {
    where: InvestmentWhereUniqueInput;
    create: InvestmentCreateInput;
    update: InvestmentUpdateInput;
  }) => InvestmentPromise;
  deleteInvestment: (where: InvestmentWhereUniqueInput) => InvestmentPromise;
  deleteManyInvestments: (where?: InvestmentWhereInput) => BatchPayloadPromise;
  createSequelizeMeta: (data: SequelizeMetaCreateInput) => SequelizeMetaPromise;
  deleteSequelizeMeta: (
    where: SequelizeMetaWhereUniqueInput
  ) => SequelizeMetaPromise;
  deleteManySequelizeMetas: (
    where?: SequelizeMetaWhereInput
  ) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (args: {
    data: TransactionUpdateInput;
    where: TransactionWhereUniqueInput;
  }) => TransactionPromise;
  updateManyTransactions: (args: {
    data: TransactionUpdateManyMutationInput;
    where?: TransactionWhereInput;
  }) => BatchPayloadPromise;
  upsertTransaction: (args: {
    where: TransactionWhereUniqueInput;
    create: TransactionCreateInput;
    update: TransactionUpdateInput;
  }) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  balanceUpdate: (
    where?: BalanceUpdateSubscriptionWhereInput
  ) => BalanceUpdateSubscriptionPayloadSubscription;
  broker: (
    where?: BrokerSubscriptionWhereInput
  ) => BrokerSubscriptionPayloadSubscription;
  investment: (
    where?: InvestmentSubscriptionWhereInput
  ) => InvestmentSubscriptionPayloadSubscription;
  sequelizeMeta: (
    where?: SequelizeMetaSubscriptionWhereInput
  ) => SequelizeMetaSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type BalanceUpdateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "date_ASC"
  | "date_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InvestmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "date_ASC"
  | "date_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BrokerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SequelizeMetaOrderByInput = "name_ASC" | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface TransactionUpdateWithoutInvestmentIdDataInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export type BalanceUpdateWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface TransactionUpdateManyDataInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export interface BrokerWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  investments_every?: Maybe<InvestmentWhereInput>;
  investments_some?: Maybe<InvestmentWhereInput>;
  investments_none?: Maybe<InvestmentWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BrokerWhereInput[] | BrokerWhereInput>;
  OR?: Maybe<BrokerWhereInput[] | BrokerWhereInput>;
  NOT?: Maybe<BrokerWhereInput[] | BrokerWhereInput>;
}

export interface InvestmentUpsertWithoutBalanceUpdatesInput {
  update: InvestmentUpdateWithoutBalanceUpdatesDataInput;
  create: InvestmentCreateWithoutBalanceUpdatesInput;
}

export interface TransactionWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  investmentId?: Maybe<InvestmentWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  OR?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  NOT?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
}

export interface InvestmentCreateWithoutBalanceUpdatesInput {
  brokerId: BrokerCreateOneWithoutInvestmentsInput;
  name: String;
  transactions?: Maybe<TransactionCreateManyWithoutInvestmentIdInput>;
}

export interface BalanceUpdateUpdateWithWhereUniqueWithoutInvestmentIdInput {
  where: BalanceUpdateWhereUniqueInput;
  data: BalanceUpdateUpdateWithoutInvestmentIdDataInput;
}

export interface BrokerCreateOneWithoutInvestmentsInput {
  create?: Maybe<BrokerCreateWithoutInvestmentsInput>;
  connect?: Maybe<BrokerWhereUniqueInput>;
}

export interface BalanceUpdateUpdateManyMutationInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export interface BrokerCreateWithoutInvestmentsInput {
  name: String;
}

export interface SequelizeMetaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SequelizeMetaWhereInput>;
  AND?: Maybe<
    SequelizeMetaSubscriptionWhereInput[] | SequelizeMetaSubscriptionWhereInput
  >;
  OR?: Maybe<
    SequelizeMetaSubscriptionWhereInput[] | SequelizeMetaSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SequelizeMetaSubscriptionWhereInput[] | SequelizeMetaSubscriptionWhereInput
  >;
}

export interface TransactionCreateManyWithoutInvestmentIdInput {
  create?: Maybe<
    | TransactionCreateWithoutInvestmentIdInput[]
    | TransactionCreateWithoutInvestmentIdInput
  >;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
}

export interface BrokerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BrokerWhereInput>;
  AND?: Maybe<BrokerSubscriptionWhereInput[] | BrokerSubscriptionWhereInput>;
  OR?: Maybe<BrokerSubscriptionWhereInput[] | BrokerSubscriptionWhereInput>;
  NOT?: Maybe<BrokerSubscriptionWhereInput[] | BrokerSubscriptionWhereInput>;
}

export interface TransactionCreateWithoutInvestmentIdInput {
  amount: Float;
  date: DateTimeInput;
}

export interface TransactionUpdateManyMutationInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export interface BalanceUpdateUpdateInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  investmentId?: Maybe<InvestmentUpdateOneRequiredWithoutBalanceUpdatesInput>;
}

export type BrokerWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface InvestmentUpdateOneRequiredWithoutBalanceUpdatesInput {
  create?: Maybe<InvestmentCreateWithoutBalanceUpdatesInput>;
  update?: Maybe<InvestmentUpdateWithoutBalanceUpdatesDataInput>;
  upsert?: Maybe<InvestmentUpsertWithoutBalanceUpdatesInput>;
  connect?: Maybe<InvestmentWhereUniqueInput>;
}

export interface InvestmentUpdateOneRequiredWithoutTransactionsInput {
  create?: Maybe<InvestmentCreateWithoutTransactionsInput>;
  update?: Maybe<InvestmentUpdateWithoutTransactionsDataInput>;
  upsert?: Maybe<InvestmentUpsertWithoutTransactionsInput>;
  connect?: Maybe<InvestmentWhereUniqueInput>;
}

export interface InvestmentUpdateWithoutBalanceUpdatesDataInput {
  brokerId?: Maybe<BrokerUpdateOneRequiredWithoutInvestmentsInput>;
  name?: Maybe<String>;
  transactions?: Maybe<TransactionUpdateManyWithoutInvestmentIdInput>;
}

export interface InvestmentCreateWithoutTransactionsInput {
  balanceUpdates?: Maybe<BalanceUpdateCreateManyWithoutInvestmentIdInput>;
  brokerId: BrokerCreateOneWithoutInvestmentsInput;
  name: String;
}

export interface BrokerUpdateOneRequiredWithoutInvestmentsInput {
  create?: Maybe<BrokerCreateWithoutInvestmentsInput>;
  update?: Maybe<BrokerUpdateWithoutInvestmentsDataInput>;
  upsert?: Maybe<BrokerUpsertWithoutInvestmentsInput>;
  connect?: Maybe<BrokerWhereUniqueInput>;
}

export interface InvestmentCreateOneWithoutTransactionsInput {
  create?: Maybe<InvestmentCreateWithoutTransactionsInput>;
  connect?: Maybe<InvestmentWhereUniqueInput>;
}

export interface BrokerUpdateWithoutInvestmentsDataInput {
  name?: Maybe<String>;
}

export interface SequelizeMetaCreateInput {
  name?: Maybe<ID_Input>;
}

export interface BrokerUpsertWithoutInvestmentsInput {
  update: BrokerUpdateWithoutInvestmentsDataInput;
  create: BrokerCreateWithoutInvestmentsInput;
}

export interface InvestmentUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface TransactionUpdateManyWithoutInvestmentIdInput {
  create?: Maybe<
    | TransactionCreateWithoutInvestmentIdInput[]
    | TransactionCreateWithoutInvestmentIdInput
  >;
  delete?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  set?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  disconnect?: Maybe<
    TransactionWhereUniqueInput[] | TransactionWhereUniqueInput
  >;
  update?: Maybe<
    | TransactionUpdateWithWhereUniqueWithoutInvestmentIdInput[]
    | TransactionUpdateWithWhereUniqueWithoutInvestmentIdInput
  >;
  upsert?: Maybe<
    | TransactionUpsertWithWhereUniqueWithoutInvestmentIdInput[]
    | TransactionUpsertWithWhereUniqueWithoutInvestmentIdInput
  >;
  deleteMany?: Maybe<
    TransactionScalarWhereInput[] | TransactionScalarWhereInput
  >;
  updateMany?: Maybe<
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput
  >;
}

export interface SequelizeMetaWhereInput {
  name?: Maybe<ID_Input>;
  name_not?: Maybe<ID_Input>;
  name_in?: Maybe<ID_Input[] | ID_Input>;
  name_not_in?: Maybe<ID_Input[] | ID_Input>;
  name_lt?: Maybe<ID_Input>;
  name_lte?: Maybe<ID_Input>;
  name_gt?: Maybe<ID_Input>;
  name_gte?: Maybe<ID_Input>;
  name_contains?: Maybe<ID_Input>;
  name_not_contains?: Maybe<ID_Input>;
  name_starts_with?: Maybe<ID_Input>;
  name_not_starts_with?: Maybe<ID_Input>;
  name_ends_with?: Maybe<ID_Input>;
  name_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<SequelizeMetaWhereInput[] | SequelizeMetaWhereInput>;
  OR?: Maybe<SequelizeMetaWhereInput[] | SequelizeMetaWhereInput>;
  NOT?: Maybe<SequelizeMetaWhereInput[] | SequelizeMetaWhereInput>;
}

export interface TransactionUpdateWithWhereUniqueWithoutInvestmentIdInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutInvestmentIdDataInput;
}

export interface BrokerUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface BalanceUpdateUpdateManyWithWhereNestedInput {
  where: BalanceUpdateScalarWhereInput;
  data: BalanceUpdateUpdateManyDataInput;
}

export interface InvestmentUpdateManyWithWhereNestedInput {
  where: InvestmentScalarWhereInput;
  data: InvestmentUpdateManyDataInput;
}

export interface TransactionUpsertWithWhereUniqueWithoutInvestmentIdInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutInvestmentIdDataInput;
  create: TransactionCreateWithoutInvestmentIdInput;
}

export interface InvestmentScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InvestmentScalarWhereInput[] | InvestmentScalarWhereInput>;
  OR?: Maybe<InvestmentScalarWhereInput[] | InvestmentScalarWhereInput>;
  NOT?: Maybe<InvestmentScalarWhereInput[] | InvestmentScalarWhereInput>;
}

export interface TransactionScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  OR?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  NOT?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
}

export interface BalanceUpdateUpdateManyDataInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export interface TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput;
  data: TransactionUpdateManyDataInput;
}

export interface BalanceUpdateCreateInput {
  amount: Float;
  date: DateTimeInput;
  investmentId: InvestmentCreateOneWithoutBalanceUpdatesInput;
}

export interface BalanceUpdateScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BalanceUpdateScalarWhereInput[] | BalanceUpdateScalarWhereInput>;
  OR?: Maybe<BalanceUpdateScalarWhereInput[] | BalanceUpdateScalarWhereInput>;
  NOT?: Maybe<BalanceUpdateScalarWhereInput[] | BalanceUpdateScalarWhereInput>;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TransactionWhereInput>;
  AND?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  OR?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
}

export interface InvestmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  balanceUpdates_every?: Maybe<BalanceUpdateWhereInput>;
  balanceUpdates_some?: Maybe<BalanceUpdateWhereInput>;
  balanceUpdates_none?: Maybe<BalanceUpdateWhereInput>;
  brokerId?: Maybe<BrokerWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  transactions_every?: Maybe<TransactionWhereInput>;
  transactions_some?: Maybe<TransactionWhereInput>;
  transactions_none?: Maybe<TransactionWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InvestmentWhereInput[] | InvestmentWhereInput>;
  OR?: Maybe<InvestmentWhereInput[] | InvestmentWhereInput>;
  NOT?: Maybe<InvestmentWhereInput[] | InvestmentWhereInput>;
}

export interface BalanceUpdateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BalanceUpdateWhereInput>;
  AND?: Maybe<
    BalanceUpdateSubscriptionWhereInput[] | BalanceUpdateSubscriptionWhereInput
  >;
  OR?: Maybe<
    BalanceUpdateSubscriptionWhereInput[] | BalanceUpdateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BalanceUpdateSubscriptionWhereInput[] | BalanceUpdateSubscriptionWhereInput
  >;
}

export interface BalanceUpdateWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  investmentId?: Maybe<InvestmentWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BalanceUpdateWhereInput[] | BalanceUpdateWhereInput>;
  OR?: Maybe<BalanceUpdateWhereInput[] | BalanceUpdateWhereInput>;
  NOT?: Maybe<BalanceUpdateWhereInput[] | BalanceUpdateWhereInput>;
}

export interface InvestmentUpdateWithoutTransactionsDataInput {
  balanceUpdates?: Maybe<BalanceUpdateUpdateManyWithoutInvestmentIdInput>;
  brokerId?: Maybe<BrokerUpdateOneRequiredWithoutInvestmentsInput>;
  name?: Maybe<String>;
}

export interface BalanceUpdateUpsertWithWhereUniqueWithoutInvestmentIdInput {
  where: BalanceUpdateWhereUniqueInput;
  update: BalanceUpdateUpdateWithoutInvestmentIdDataInput;
  create: BalanceUpdateCreateWithoutInvestmentIdInput;
}

export type InvestmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface BalanceUpdateUpdateWithoutInvestmentIdDataInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export type SequelizeMetaWhereUniqueInput = AtLeastOne<{
  name: Maybe<ID_Input>;
}>;

export interface BrokerCreateInput {
  investments?: Maybe<InvestmentCreateManyWithoutBrokerIdInput>;
  name: String;
}

export interface InvestmentCreateInput {
  balanceUpdates?: Maybe<BalanceUpdateCreateManyWithoutInvestmentIdInput>;
  brokerId: BrokerCreateOneWithoutInvestmentsInput;
  name: String;
  transactions?: Maybe<TransactionCreateManyWithoutInvestmentIdInput>;
}

export interface InvestmentCreateManyWithoutBrokerIdInput {
  create?: Maybe<
    | InvestmentCreateWithoutBrokerIdInput[]
    | InvestmentCreateWithoutBrokerIdInput
  >;
  connect?: Maybe<InvestmentWhereUniqueInput[] | InvestmentWhereUniqueInput>;
}

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface InvestmentCreateWithoutBrokerIdInput {
  balanceUpdates?: Maybe<BalanceUpdateCreateManyWithoutInvestmentIdInput>;
  name: String;
  transactions?: Maybe<TransactionCreateManyWithoutInvestmentIdInput>;
}

export interface InvestmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InvestmentWhereInput>;
  AND?: Maybe<
    InvestmentSubscriptionWhereInput[] | InvestmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    InvestmentSubscriptionWhereInput[] | InvestmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    InvestmentSubscriptionWhereInput[] | InvestmentSubscriptionWhereInput
  >;
}

export interface BalanceUpdateCreateManyWithoutInvestmentIdInput {
  create?: Maybe<
    | BalanceUpdateCreateWithoutInvestmentIdInput[]
    | BalanceUpdateCreateWithoutInvestmentIdInput
  >;
  connect?: Maybe<
    BalanceUpdateWhereUniqueInput[] | BalanceUpdateWhereUniqueInput
  >;
}

export interface TransactionUpdateInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  investmentId?: Maybe<InvestmentUpdateOneRequiredWithoutTransactionsInput>;
}

export interface BalanceUpdateCreateWithoutInvestmentIdInput {
  amount: Float;
  date: DateTimeInput;
}

export interface InvestmentUpdateInput {
  balanceUpdates?: Maybe<BalanceUpdateUpdateManyWithoutInvestmentIdInput>;
  brokerId?: Maybe<BrokerUpdateOneRequiredWithoutInvestmentsInput>;
  name?: Maybe<String>;
  transactions?: Maybe<TransactionUpdateManyWithoutInvestmentIdInput>;
}

export interface BrokerUpdateInput {
  investments?: Maybe<InvestmentUpdateManyWithoutBrokerIdInput>;
  name?: Maybe<String>;
}

export interface InvestmentUpsertWithWhereUniqueWithoutBrokerIdInput {
  where: InvestmentWhereUniqueInput;
  update: InvestmentUpdateWithoutBrokerIdDataInput;
  create: InvestmentCreateWithoutBrokerIdInput;
}

export interface BalanceUpdateUpdateManyWithoutInvestmentIdInput {
  create?: Maybe<
    | BalanceUpdateCreateWithoutInvestmentIdInput[]
    | BalanceUpdateCreateWithoutInvestmentIdInput
  >;
  delete?: Maybe<
    BalanceUpdateWhereUniqueInput[] | BalanceUpdateWhereUniqueInput
  >;
  connect?: Maybe<
    BalanceUpdateWhereUniqueInput[] | BalanceUpdateWhereUniqueInput
  >;
  set?: Maybe<BalanceUpdateWhereUniqueInput[] | BalanceUpdateWhereUniqueInput>;
  disconnect?: Maybe<
    BalanceUpdateWhereUniqueInput[] | BalanceUpdateWhereUniqueInput
  >;
  update?: Maybe<
    | BalanceUpdateUpdateWithWhereUniqueWithoutInvestmentIdInput[]
    | BalanceUpdateUpdateWithWhereUniqueWithoutInvestmentIdInput
  >;
  upsert?: Maybe<
    | BalanceUpdateUpsertWithWhereUniqueWithoutInvestmentIdInput[]
    | BalanceUpdateUpsertWithWhereUniqueWithoutInvestmentIdInput
  >;
  deleteMany?: Maybe<
    BalanceUpdateScalarWhereInput[] | BalanceUpdateScalarWhereInput
  >;
  updateMany?: Maybe<
    | BalanceUpdateUpdateManyWithWhereNestedInput[]
    | BalanceUpdateUpdateManyWithWhereNestedInput
  >;
}

export interface InvestmentUpdateWithoutBrokerIdDataInput {
  balanceUpdates?: Maybe<BalanceUpdateUpdateManyWithoutInvestmentIdInput>;
  name?: Maybe<String>;
  transactions?: Maybe<TransactionUpdateManyWithoutInvestmentIdInput>;
}

export interface InvestmentUpdateWithWhereUniqueWithoutBrokerIdInput {
  where: InvestmentWhereUniqueInput;
  data: InvestmentUpdateWithoutBrokerIdDataInput;
}

export interface InvestmentUpdateManyWithoutBrokerIdInput {
  create?: Maybe<
    | InvestmentCreateWithoutBrokerIdInput[]
    | InvestmentCreateWithoutBrokerIdInput
  >;
  delete?: Maybe<InvestmentWhereUniqueInput[] | InvestmentWhereUniqueInput>;
  connect?: Maybe<InvestmentWhereUniqueInput[] | InvestmentWhereUniqueInput>;
  set?: Maybe<InvestmentWhereUniqueInput[] | InvestmentWhereUniqueInput>;
  disconnect?: Maybe<InvestmentWhereUniqueInput[] | InvestmentWhereUniqueInput>;
  update?: Maybe<
    | InvestmentUpdateWithWhereUniqueWithoutBrokerIdInput[]
    | InvestmentUpdateWithWhereUniqueWithoutBrokerIdInput
  >;
  upsert?: Maybe<
    | InvestmentUpsertWithWhereUniqueWithoutBrokerIdInput[]
    | InvestmentUpsertWithWhereUniqueWithoutBrokerIdInput
  >;
  deleteMany?: Maybe<InvestmentScalarWhereInput[] | InvestmentScalarWhereInput>;
  updateMany?: Maybe<
    | InvestmentUpdateManyWithWhereNestedInput[]
    | InvestmentUpdateManyWithWhereNestedInput
  >;
}

export interface InvestmentCreateOneWithoutBalanceUpdatesInput {
  create?: Maybe<InvestmentCreateWithoutBalanceUpdatesInput>;
  connect?: Maybe<InvestmentWhereUniqueInput>;
}

export interface InvestmentUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface TransactionCreateInput {
  amount: Float;
  date: DateTimeInput;
  investmentId: InvestmentCreateOneWithoutTransactionsInput;
}

export interface InvestmentUpsertWithoutTransactionsInput {
  update: InvestmentUpdateWithoutTransactionsDataInput;
  create: InvestmentCreateWithoutTransactionsInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface TransactionPreviousValues {
  id: Int;
  amount: Float;
  createdAt: DateTimeOutput;
  date: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  amount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  amount: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBroker {
  count: Int;
}

export interface AggregateBrokerPromise
  extends Promise<AggregateBroker>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBrokerSubscription
  extends Promise<AsyncIterator<AggregateBroker>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InvestmentPreviousValues {
  id: Int;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface InvestmentPreviousValuesPromise
  extends Promise<InvestmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InvestmentPreviousValuesSubscription
  extends Promise<AsyncIterator<InvestmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BrokerEdge {
  node: Broker;
  cursor: String;
}

export interface BrokerEdgePromise extends Promise<BrokerEdge>, Fragmentable {
  node: <T = BrokerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BrokerEdgeSubscription
  extends Promise<AsyncIterator<BrokerEdge>>,
    Fragmentable {
  node: <T = BrokerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Broker {
  id: Int;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface BrokerPromise extends Promise<Broker>, Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  investments: <T = FragmentableArray<Investment>>(args?: {
    where?: InvestmentWhereInput;
    orderBy?: InvestmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BrokerSubscription
  extends Promise<AsyncIterator<Broker>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  investments: <T = Promise<AsyncIterator<InvestmentSubscription>>>(args?: {
    where?: InvestmentWhereInput;
    orderBy?: InvestmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BrokerNullablePromise
  extends Promise<Broker | null>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  investments: <T = FragmentableArray<Investment>>(args?: {
    where?: InvestmentWhereInput;
    orderBy?: InvestmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BrokerConnection {
  pageInfo: PageInfo;
  edges: BrokerEdge[];
}

export interface BrokerConnectionPromise
  extends Promise<BrokerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BrokerEdge>>() => T;
  aggregate: <T = AggregateBrokerPromise>() => T;
}

export interface BrokerConnectionSubscription
  extends Promise<AsyncIterator<BrokerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BrokerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBrokerSubscription>() => T;
}

export interface Investment {
  id: Int;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface InvestmentPromise extends Promise<Investment>, Fragmentable {
  id: () => Promise<Int>;
  balanceUpdates: <T = FragmentableArray<BalanceUpdate>>(args?: {
    where?: BalanceUpdateWhereInput;
    orderBy?: BalanceUpdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  brokerId: <T = BrokerPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InvestmentSubscription
  extends Promise<AsyncIterator<Investment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  balanceUpdates: <
    T = Promise<AsyncIterator<BalanceUpdateSubscription>>
  >(args?: {
    where?: BalanceUpdateWhereInput;
    orderBy?: BalanceUpdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  brokerId: <T = BrokerSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InvestmentNullablePromise
  extends Promise<Investment | null>,
    Fragmentable {
  id: () => Promise<Int>;
  balanceUpdates: <T = FragmentableArray<BalanceUpdate>>(args?: {
    where?: BalanceUpdateWhereInput;
    orderBy?: BalanceUpdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  brokerId: <T = BrokerPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBalanceUpdate {
  count: Int;
}

export interface AggregateBalanceUpdatePromise
  extends Promise<AggregateBalanceUpdate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBalanceUpdateSubscription
  extends Promise<AsyncIterator<AggregateBalanceUpdate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSequelizeMeta {
  count: Int;
}

export interface AggregateSequelizeMetaPromise
  extends Promise<AggregateSequelizeMeta>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSequelizeMetaSubscription
  extends Promise<AsyncIterator<AggregateSequelizeMeta>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BalanceUpdateEdge {
  node: BalanceUpdate;
  cursor: String;
}

export interface BalanceUpdateEdgePromise
  extends Promise<BalanceUpdateEdge>,
    Fragmentable {
  node: <T = BalanceUpdatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BalanceUpdateEdgeSubscription
  extends Promise<AsyncIterator<BalanceUpdateEdge>>,
    Fragmentable {
  node: <T = BalanceUpdateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SequelizeMetaConnection {
  pageInfo: PageInfo;
  edges: SequelizeMetaEdge[];
}

export interface SequelizeMetaConnectionPromise
  extends Promise<SequelizeMetaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SequelizeMetaEdge>>() => T;
  aggregate: <T = AggregateSequelizeMetaPromise>() => T;
}

export interface SequelizeMetaConnectionSubscription
  extends Promise<AsyncIterator<SequelizeMetaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SequelizeMetaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSequelizeMetaSubscription>() => T;
}

export interface Transaction {
  id: Int;
  amount: Float;
  createdAt: DateTimeOutput;
  date: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<Int>;
  amount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  investmentId: <T = InvestmentPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  amount: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  investmentId: <T = InvestmentSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TransactionNullablePromise
  extends Promise<Transaction | null>,
    Fragmentable {
  id: () => Promise<Int>;
  amount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  investmentId: <T = InvestmentPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SequelizeMeta {
  name: ID_Output;
}

export interface SequelizeMetaPromise
  extends Promise<SequelizeMeta>,
    Fragmentable {
  name: () => Promise<ID_Output>;
}

export interface SequelizeMetaSubscription
  extends Promise<AsyncIterator<SequelizeMeta>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SequelizeMetaNullablePromise
  extends Promise<SequelizeMeta | null>,
    Fragmentable {
  name: () => Promise<ID_Output>;
}

export interface BalanceUpdate {
  id: Int;
  amount: Float;
  createdAt: DateTimeOutput;
  date: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BalanceUpdatePromise
  extends Promise<BalanceUpdate>,
    Fragmentable {
  id: () => Promise<Int>;
  amount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  investmentId: <T = InvestmentPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BalanceUpdateSubscription
  extends Promise<AsyncIterator<BalanceUpdate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  amount: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  investmentId: <T = InvestmentSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BalanceUpdateNullablePromise
  extends Promise<BalanceUpdate | null>,
    Fragmentable {
  id: () => Promise<Int>;
  amount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  investmentId: <T = InvestmentPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateInvestment {
  count: Int;
}

export interface AggregateInvestmentPromise
  extends Promise<AggregateInvestment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInvestmentSubscription
  extends Promise<AsyncIterator<AggregateInvestment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BalanceUpdateSubscriptionPayload {
  mutation: MutationType;
  node: BalanceUpdate;
  updatedFields: String[];
  previousValues: BalanceUpdatePreviousValues;
}

export interface BalanceUpdateSubscriptionPayloadPromise
  extends Promise<BalanceUpdateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BalanceUpdatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BalanceUpdatePreviousValuesPromise>() => T;
}

export interface BalanceUpdateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BalanceUpdateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BalanceUpdateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BalanceUpdatePreviousValuesSubscription>() => T;
}

export interface InvestmentConnection {
  pageInfo: PageInfo;
  edges: InvestmentEdge[];
}

export interface InvestmentConnectionPromise
  extends Promise<InvestmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InvestmentEdge>>() => T;
  aggregate: <T = AggregateInvestmentPromise>() => T;
}

export interface InvestmentConnectionSubscription
  extends Promise<AsyncIterator<InvestmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InvestmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInvestmentSubscription>() => T;
}

export interface BalanceUpdatePreviousValues {
  id: Int;
  amount: Float;
  createdAt: DateTimeOutput;
  date: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BalanceUpdatePreviousValuesPromise
  extends Promise<BalanceUpdatePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  amount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BalanceUpdatePreviousValuesSubscription
  extends Promise<AsyncIterator<BalanceUpdatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  amount: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface SequelizeMetaEdge {
  node: SequelizeMeta;
  cursor: String;
}

export interface SequelizeMetaEdgePromise
  extends Promise<SequelizeMetaEdge>,
    Fragmentable {
  node: <T = SequelizeMetaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SequelizeMetaEdgeSubscription
  extends Promise<AsyncIterator<SequelizeMetaEdge>>,
    Fragmentable {
  node: <T = SequelizeMetaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SequelizeMetaSubscriptionPayload {
  mutation: MutationType;
  node: SequelizeMeta;
  updatedFields: String[];
  previousValues: SequelizeMetaPreviousValues;
}

export interface SequelizeMetaSubscriptionPayloadPromise
  extends Promise<SequelizeMetaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SequelizeMetaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SequelizeMetaPreviousValuesPromise>() => T;
}

export interface SequelizeMetaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SequelizeMetaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SequelizeMetaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SequelizeMetaPreviousValuesSubscription>() => T;
}

export interface InvestmentSubscriptionPayload {
  mutation: MutationType;
  node: Investment;
  updatedFields: String[];
  previousValues: InvestmentPreviousValues;
}

export interface InvestmentSubscriptionPayloadPromise
  extends Promise<InvestmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvestmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvestmentPreviousValuesPromise>() => T;
}

export interface InvestmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InvestmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InvestmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvestmentPreviousValuesSubscription>() => T;
}

export interface BalanceUpdateConnection {
  pageInfo: PageInfo;
  edges: BalanceUpdateEdge[];
}

export interface BalanceUpdateConnectionPromise
  extends Promise<BalanceUpdateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BalanceUpdateEdge>>() => T;
  aggregate: <T = AggregateBalanceUpdatePromise>() => T;
}

export interface BalanceUpdateConnectionSubscription
  extends Promise<AsyncIterator<BalanceUpdateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BalanceUpdateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBalanceUpdateSubscription>() => T;
}

export interface BrokerPreviousValues {
  id: Int;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface BrokerPreviousValuesPromise
  extends Promise<BrokerPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BrokerPreviousValuesSubscription
  extends Promise<AsyncIterator<BrokerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BrokerSubscriptionPayload {
  mutation: MutationType;
  node: Broker;
  updatedFields: String[];
  previousValues: BrokerPreviousValues;
}

export interface BrokerSubscriptionPayloadPromise
  extends Promise<BrokerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BrokerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BrokerPreviousValuesPromise>() => T;
}

export interface BrokerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BrokerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BrokerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BrokerPreviousValuesSubscription>() => T;
}

export interface InvestmentEdge {
  node: Investment;
  cursor: String;
}

export interface InvestmentEdgePromise
  extends Promise<InvestmentEdge>,
    Fragmentable {
  node: <T = InvestmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InvestmentEdgeSubscription
  extends Promise<AsyncIterator<InvestmentEdge>>,
    Fragmentable {
  node: <T = InvestmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SequelizeMetaPreviousValues {
  name: ID_Output;
}

export interface SequelizeMetaPreviousValuesPromise
  extends Promise<SequelizeMetaPreviousValues>,
    Fragmentable {
  name: () => Promise<ID_Output>;
}

export interface SequelizeMetaPreviousValuesSubscription
  extends Promise<AsyncIterator<SequelizeMetaPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<ID_Output>>;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "BalanceUpdate",
    embedded: false
  },
  {
    name: "Broker",
    embedded: false
  },
  {
    name: "Investment",
    embedded: false
  },
  {
    name: "SequelizeMeta",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
